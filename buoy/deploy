#!/usr/bin/env python3

import argparse
import subprocess
import threading
import yaml
import sys
from pathlib import Path

SRC_DIR = Path("src").resolve()


def run_cmd(cmd):
    return subprocess.run(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )


def ping_host(host, count):
    return run_cmd([
        "ping", "-c", str(count), host
    ]).returncode == 0


def worker(target, show_all, run_after, results, lock):
    name = target["name"]
    host = target["host"]
    path = target["path"]
    hostname = host.split("@")[-1]
    prefix = f"[{name}] "

    try:
        # 1Ô∏è‚É£ Ping once
        if not ping_host(hostname, 1):
            print(prefix + "initial ping failed, retrying...")
            if not ping_host(hostname, 5):
                raise RuntimeError("unreachable (ping failed)")

        print(prefix + "reachable")

        # 2Ô∏è‚É£ Ensure directory structure
        mkdir = run_cmd([
            "ssh", host,
            f"mkdir -p {path}/src {path}/build"
        ])
        if mkdir.returncode != 0:
            raise RuntimeError(mkdir.stderr)

        # 3Ô∏è‚É£ Sync source
        rsync = run_cmd([
            "rsync", "-az", "--delete",
            f"{SRC_DIR}/",
            f"{host}:{path}/src/"
        ])
        if rsync.returncode != 0:
            raise RuntimeError(rsync.stderr)

        # 4Ô∏è‚É£ Configure
        configure = run_cmd([
            "ssh", host,
            f"cd {path}/build && cmake ../src"
        ])
        if configure.returncode != 0:
            raise RuntimeError(configure.stderr)

        # 5Ô∏è‚É£ Build
        build = run_cmd([
            "ssh", host,
            f"cd {path}/build && cmake --build ."
        ])
        if build.returncode != 0:
            raise RuntimeError(build.stderr)

        # 6Ô∏è‚É£ Run (optional, capture max 5s of output)
        output = ""

        if run_after:
            proc = subprocess.Popen(
                ["ssh", host, f"{path}/build/buoy_app"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            try:
                stdout, stderr = proc.communicate(timeout=5)
                output = stdout

                if proc.returncode not in (0, None):
                    raise RuntimeError(stderr)

            except subprocess.TimeoutExpired:
                # Stop waiting after 5 seconds; leave remote process running
                proc.kill()
                output += "[output truncated after 5s]\n"

        with lock:
            results.append({
                "name": name,
                "error": None,
                "output": output,
            })

    except Exception as e:
        print(prefix + str(e))
        with lock:
            results.append({
                "name": name,
                "error": str(e),
                "output": str(e) if show_all else "",
            })


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("command", choices=["build", "run"])
    parser.add_argument("-a", "--all", action="store_true",
                        help="Show output from all targets")
    args = parser.parse_args()

    with open("targets.yaml") as f:
        targets = yaml.safe_load(f)["targets"]

    threads = []
    results = []
    lock = threading.Lock()

    for t in targets:
        thread = threading.Thread(
            target=worker,
            args=(t, args.all, args.command == "run", results, lock)
        )
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    unreachable = [
        r for r in results if r["error"] and "unreachable" in r["error"]
    ]

    if unreachable:
        print("\nüö´ Aborting: unreachable targets detected\n")
        for r in unreachable:
            print(f"[{r['name']}] unreachable")
        sys.exit(1)

    failures = [r for r in results if r["error"]]

    if failures:
        first = failures[0]
        print(f"\n‚ùå Build failed on {first['name']}:\n")
        print(first["error"])
        sys.exit(1)

    print("\n‚úÖ Success on all targets\n")

    if args.all:
        for r in results:
            print(f"[{r['name']}]")
            print(r["output"])


if __name__ == "__main__":
    main()